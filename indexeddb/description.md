## IndexedDB для внешнего хранилища

### IndexedDB

Прежде чем использовать технологию, сначала поймите, что это такое. Это очень важно для вашего понимания. Как вы можете видеть из БД, это должна быть база данных. Когда речь идет о базах данных, есть два разных типа баз данных, которые являются реляционными. Базы данных и нереляционные базы данных Реляционные базы данных, такие как Mysql и Oracle, хранят данные в таблицах, а нереляционные базы данных, такие как Redis и MongoDB, хранят наборы данных как отдельные объекты. indexedDB - это нереляционная база данных, она не требует написания определенных операторов SQL для работы с базой данных, потому что это nosql, форма данных использует json,

### Значение indexedDB

Может быть, те, кто знаком с интерфейсным хранилищем, скажут, у них нет LocalStorage и Cookies? Зачем запускать indexedDB? Фактически, для хранения данных в браузере вы можете использовать куки или локальное хранилище, но это относительно простые технологии, и IndexedDB обеспечивает аналогичное хранение и использование данных в стиле базы данных.

Позвольте мне сначала поговорить о файлах cookie. Английский перевод - это маленький десерт. Звучит восхитительно. На самом деле это не так. Каждый раз, когда HTTP принимает и отправляет данные Cookies, он потребляет дополнительный трафик. Например, если у вас есть данные cookie размером 10 КБ и вы отправили 10 запросов, то в сети будет передано 100 КБ данных. Печенье может быть только строкой. Место для хранения файлов cookie в браузерах ограничено, и многие пользователи запрещают использование файлов cookie в браузерах. Поэтому файлы cookie могут использоваться только для хранения небольших объемов некритических данных.

Во-вторых, поговорим о LocalStorage. LocalStorage использует режим значения ключа для хранения данных, но, в отличие от IndexedDB, его данные не хранятся в форме объектов. Данные, которые он хранит в форме строк. Если вы хотите, чтобы LocalStorage сохранял объекты, вам необходимо использовать JSON.stringify () для преобразования объекта в строковую форму, а затем использовать JSON.parse () для восстановления строки в объект. Но если вы хотите хранить большие объемы сложных данных, это не очень хорошее решение. В конце концов, localstorage специально разработан для небольших объемов данных, поэтому его API-интерфейсы предназначены для синхронизации. IndexedDB очень подходит для хранения больших объемов данных, и его API вызывается асинхронно. IndexedDB использует индексы для хранения данных, и различные транзакции базы данных выполняются в транзакциях. IndexedDB даже поддерживает простые типы данных. IndexedDB намного мощнее, чем локальное хранилище, но его API также относительно сложен. Для простых данных вы должны продолжать использовать локальное хранилище, но когда вы хотите хранить большой объем данных, IndexedDB будет явно более подходящим. IndexedDB может предоставить вам более сложный способ запроса данных.

### функции indexedDB

1\. Объект склад

С помощью базы данных мы, естественно, хотим создать таблицу для хранения данных, но в indexedDB нет концепции таблицы, но objectStore, база данных может содержать несколько объектов ObjectStore, objectStore - это гибкая структура данных, может хранить несколько типов данных. , То есть objectStore эквивалентен таблице, каждая сохраненная в ней информация связана с ключом. Мы можем использовать указанное поле в каждой записи в качестве значения ключа (keyPath), или мы можем использовать автоматически генерируемое добавочное число в качестве значения ключа (keyGenerator), или не указано. Тип ключа выбора отличается, и структура данных, которую может хранить objectStore, также отличается.

|

**Тип ключа**

 |

**Хранение данных**

 |
|

Не используй

 |

Любое значение, но вам нужно указать параметр ключа, когда вы не добавляете часть данных

 |
|

keyPath

 |

Любое значение, но вам нужно указать параметр ключа, когда вы не добавляете часть данных

 |
|

keyGenerator

 |

Любое значение

 |
|

Все используют

 |

Объект Javascript, если в объекте указан атрибут, указанный с помощью keyPath, новое значение ключа не будет создано, если автоматически не сгенерировано добавочное значение ключа, заполните атрибут, указанный с помощью keyPath

 |

![](https://russianblogs.com/images/710/4dcdb836deb4112ee0a1f5e89d4514de.png)

Как показано на рисунке выше, существует хранилище объектов для хранения людей, и ключом этого хранилища является значение идентификатора человека.

2\. Транзакционный

В indexedDB каждая операция с базой данных выполняется в контексте транзакции. Область транзакции влияет на одно или несколько хранилищ объектов одновременно. Вы определяете это, передавая массив имен хранилищ объектов в функцию, которая создает область транзакции. Например: db.transaction (storeName, 'readwrite'), второй параметр для создания транзакции - это режим транзакции. При запросе транзакции вы должны решить, запрашивать ли доступ в режиме только для чтения или в режиме чтения-записи.

3\. На основании запроса

Каждая операция в базе данных indexedDB описывается как открытие базы данных с помощью запроса, доступ к хранилищу объектов и продолжение. API IndexedDB по своей сути основан на запросах, что также указывает на асинхронную природу API. Для каждой операции, которую вы выполняете в базе данных, вы должны сначала создать запрос для этой операции. Когда запрос завершен, вы можете ответить на события и ошибки, возникшие в результате запроса.

4\. Асинхронный

Большинство операций в IndexedDB - это не наш обычно используемый метод вызова и возврата результатов, а режим запроса-ответа.Так называемый асинхронный API означает, что эта инструкция не выполнена, мы можем использовать request.result для получения объекта indexedDB Как и при использовании ajax, завершение оператора не означает, что объект был получен, поэтому мы обычно обрабатываем его в функции обратного вызова.

### как играть в indexedDB

Основные режимы, поддерживаемые IndexedDB:

1.  Откройте базу данных и начните транзакцию.
2.  Создать хранилище объектов.
3.  Создайте запрос для выполнения некоторых операций с базой данных, таких как добавление или извлечение данных.
4.  Дождитесь завершения операции, прослушивая правильный тип события DOM.
5.  Выполнить некоторые операции с результатами операции (можно найти в объекте запроса)

Далее, если вы хотите понять, как работает indexedDB, лучше всего создать простое веб-приложение: сохранить имя, телефон и адрес человека в IndexedDB. IndexedDB предоставляет простые интерфейсы добавления, удаления, изменения и проверки.

 ![](https://russianblogs.com/images/502/74ec0d04f6f7b0fd8ec4e0f543cb06ee.png)

**1\. Откройте базу данных**

а) Прежде всего, вам необходимо знать, поддерживает ли ваш браузер IndexedDB.

var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;
if(!indexedDB)
{
    console.log («Ваш браузер не поддерживает IndexedDB»);
}

б) Создайте запрос на открытие indexedDB: как только ваш браузер поддерживает IndexedDB, мы можем его открыть. Вы не можете напрямую открыть базу данных IndexedDB. IndexedDB требует, чтобы вы создали запрос, чтобы открыть его.

var request = indexedDB.open(name, version);

Первый параметр - это имя базы данных, а второй параметр - номер версии базы данных. Номер версии можно использовать для настройки структуры базы данных и данных при обновлении базы данных. Но когда вы увеличиваете номер версии базы данных, будет вызвано событие onupgradeneeded. В это время может быть три случая успеха, сбоя и блокировки событий:

request.onerror = function(e) {
        console.log(e.currentTarget.error.message);
    };

    request.onsuccess = function(e) {
        myDB.db = e.target.result;
                 console.log («БД успешно открыта»);
    };

    request.onupgradeneeded = function(e) {
        var db = e.target.result;
        if (!db.objectStoreNames.contains('person')) {
                         console.log («Мне нужно создать новый объект хранения»);
                         // Если таблица не существует, создайте новую таблицу (keyPath, первичный ключ; autoIncrement, увеличивать ли автоматически), она вернет объект (objectStore)
            var objectStore = db.createObjectStore('person', {
                keyPath: "id",
                autoIncrement: true
            });

                         // Укажите поле, которое можно проиндексировать, является ли уникальное поле уникальным

            objectStore.createIndex("name", "name", {
                unique: false
            });

            objectStore.createIndex("phone", "phone", {
                unique: false
            });

        }
                 console.log ('Версия базы данных изменена на:' + версия);
};

Событие onupgradeneeded будет вызываться при первом открытии страницы для инициализации базы данных или при изменении номера версии. Поэтому вы должны создать свои сохраненные данные в функции onupgradeneeded. Если номер версии не изменился и страница была открыта ранее, вы получите событие onsuccess.

**2\. Добавить данные**

а) Во-первых, вам нужно создать транзакцию и требовать разрешения на чтение и запись

var transaction = db.transaction(storeName, 'readwrite');

б) Получить objectStore, а затем вызвать метод add для добавления данных

var store = transaction.objectStore(storeName);

    var request = store.get(key);

    request.onsuccess = function(e) {

        data = e.target.result;

        console.log(student.name);

};

**3\. Удалить данные**

Удаление аналогично добавлению. Вам необходимо создать транзакцию, а затем вызвать интерфейс удаления, чтобы удалить объекты по ключу.

var transaction = db.transaction(storeName, 'readwrite');

    var store = transaction.objectStore(storeName);

store.delete(key);

**4\. Найти данные**

а) Найти по ключу

Запустите транзакцию, получите objectStore, вызовите метод get (), передайте значение ключа объекта в метод и извлеките соответствующий объект.

var transaction = db.transaction(storeName, 'readwrite');

    var store = transaction.objectStore(storeName);

    var request = store.get(key);

    request.onsuccess = function(e) {

        data = e.target.result;

        console.log(student.name);

};

б) использовать поиск по индексу

Мы можем указать индекс при создании хранилища объектов и использовать индекс создания хранилища объектов для создания индекса.Этот метод имеет три параметра: имя индекса, имя поля атрибута индекса и уникальность значения атрибута индекса.

objectStore.createIndex("name", "name", {
                unique: false

            });

Как и в приведенном выше коде, мы создали индекс имени, и мы можем использовать индекс для запроса:

var transaction = db.transaction(storeName);

    var store = transaction.objectStore(storeName);

    var index = store.index(search\_index);

    index.get(value).onsuccess = function(e) {

        data = e.target.result;

        console.log(student.id);

}

в) данные обхода курсора

Студенты, знакомые с базой данных, могут понять роль курсора. С помощью курсора хранилища объектов базы данных мы можем использовать курсор для перемещения по хранилищу объектов.

var transaction = db.transaction(storeName);

    var store = transaction.objectStore(storeName);

         var request = store.openCursor (); // Открыть курсор

    var dataList = new Array();

    var i = 0;

    request.onsuccess = function(e) {

        var cursor = e.target.result;

        if (cursor) {

            console.log(cursor.key);

            dataList\[i\] = cursor.value;

            console.log(dataList\[i\].name);

            i++;

            cursor.continue();

        }

        data = dataList;

};

**4\. Обновить объекты**

Чтобы обновить объект, сначала выньте его, измените его, а затем верните обратно.

var transaction = db.transaction(storeName, 'readwrite');

    var store = transaction.objectStore(storeName);

    var request = store.get(key);

    request.onsuccess = function(e) {

        var data = e.target.result;

        for (a in newData) {

                         // В дополнение к ключевому пути

            data.a = newData.a;

        }

        store.put(data);

};

**5\. Закройте и удалите базу данных**

Закрыть базу данных можно напрямую вызывать метод close объекта базы данных

function closeDB(db) {

    db.close();

}

Удалить базу данных, используя метод deleteDatabase объектов базы данных

function deleteDB(name) {

    indexedDB.deleteDatabase(name);

}

### подводить итоги

Выше приведены некоторые основные концепции и использование indexedDB. Из-за нехватки места, есть некоторые более подробные детали, которые не представлены. Например, указатели indexedDB в сочетании с индексами дают полную возможность использовать их истинные преимущества. Заинтересованные партнеры могут продолжить углубленное изучение. Обратите внимание на проблемы поддержки браузера, IE9 и более ранние версии не поддерживают, Firefox и Google Chrome не имеют проблем
